<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MediaPipe Head Box (BlazeFace Short Range)</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #1e1e1e;
        font-family: "Segoe UI", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
      }

      h1 {
        margin: 10px 0;
        font-size: 1.2rem;
      }

      .container {
        position: relative;
        width: 640px;
        height: 480px;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      }

      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: rotateY(180deg);
        object-fit: cover;
      }

      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: rotateY(180deg);
        pointer-events: none;
      }

      button {
        margin-top: 15px;
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      button:disabled {
        background-color: #555;
      }

      .loading {
        color: #ffc107;
        margin-top: 5px;
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <h1>Head Box Tracking (BlazeFace Short Range)</h1>

    <div class="container">
      <video id="webcam" autoplay playsinline></video>
      <canvas id="output_canvas"></canvas>
    </div>

    <div id="loadingMsg" class="loading">Loading MediaPipe Model...</div>
    <button id="webcamButton" disabled>ENABLE WEBCAM</button>

    <script type="module">
      import { FaceDetector, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

      const video = document.getElementById("webcam");
      const canvasElement = document.getElementById("output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const enableWebcamButton = document.getElementById("webcamButton");
      const loadingMsg = document.getElementById("loadingMsg");

      let faceDetector = undefined;
      let webcamRunning = false;
      let lastVideoTime = -1;

      const createFaceDetector = async () => {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
        faceDetector = await FaceDetector.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
        });
        loadingMsg.style.display = "none";
        enableWebcamButton.disabled = false;
      };
      createFaceDetector();

      function drawHeadBoxes(detections) {
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.lineWidth = 3;
        canvasCtx.strokeStyle = "#00ff84";

        for (const detection of detections) {
          const { originX, originY, width, height } = detection.boundingBox;
          canvasCtx.strokeRect(originX, originY, width, height);
        }
      }

      async function predictWebcam() {
        if (canvasElement.width !== video.videoWidth || canvasElement.height !== video.videoHeight) {
          canvasElement.width = video.videoWidth;
          canvasElement.height = video.videoHeight;
        }

        const startTimeMs = performance.now();
        if (lastVideoTime !== video.currentTime) {
          lastVideoTime = video.currentTime;
          const detections = faceDetector.detectForVideo(video, startTimeMs).detections;
          drawHeadBoxes(detections);
        }

        if (webcamRunning) {
          window.requestAnimationFrame(predictWebcam);
        }
      }

      function enableCam() {
        if (!faceDetector) {
          alert("Please wait for model to load");
          return;
        }

        if (webcamRunning) {
          webcamRunning = false;
          enableWebcamButton.innerText = "ENABLE WEBCAM";
          const stream = video.srcObject;
          const tracks = stream.getTracks();
          tracks.forEach((track) => track.stop());
          video.srcObject = null;
          canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        } else {
          webcamRunning = true;
          enableWebcamButton.innerText = "DISABLE WEBCAM";
          const constraints = { video: { width: 640, height: 480 } };
          navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
            video.srcObject = stream;
            video.addEventListener("loadeddata", predictWebcam);
          });
        }
      }

      enableWebcamButton.addEventListener("click", enableCam);
    </script>
  </body>
</html>
