<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MediaPipe Holistic - Refined Hand and Face Tracking with Recrop Technique</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #1e1e1e;
        font-family: "Segoe UI", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
      }

      h1 {
        margin: 10px 0;
        font-size: 1.2rem;
      }

      .description {
        font-size: 0.9rem;
        color: #aaa;
        margin-bottom: 10px;
        text-align: center;
        max-width: 800px;
      }

      .container {
        position: relative;
        width: 1280px;
        height: 720px;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      }

      .input_video {
        display: none;
      }

      .output_canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
      }

      .fps {
        position: absolute;
        top: 10px;
        right: 10px;
        color: white;
        font-family: monospace;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 10;
        transform: scaleX(-1);
      }

      .tracking-status {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: monospace;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 10;
        transform: scaleX(-1);
        text-align: right;
        line-height: 1.6;
      }

      .controls {
        margin-top: 15px;
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
        max-width: 1280px;
      }

      label {
        font-size: 0.9rem;
        cursor: pointer;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 5px;
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 12px;
        border-radius: 6px;
      }

      input[type="checkbox"] {
        cursor: pointer;
      }

      .legend {
        margin-top: 15px;
        display: flex;
        gap: 20px;
        font-size: 0.85rem;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 2px solid;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <h1>Refined Hand and Face Tracking with Recrop Technique</h1>
    <p class="description">
      This demo uses MediaPipe Holistic with the recrop technique for precise hand and face tracking. The holistic pipeline first estimates pose, then uses
      re-crop models to refine ROIs for hands and face before running detailed landmark models (21 hand landmarks per hand, 468 face landmarks).
    </p>

    <div class="container">
      <video class="input_video"></video>
      <canvas class="output_canvas"></canvas>
      <div class="fps" id="fpsDisplay">FPS: 0</div>
      <div class="tracking-status" id="trackingStatus">
        Face: --<br />
        Left Hand: --<br />
        Right Hand: --
      </div>
    </div>

    <div class="controls">
      <div class="control-group">
        <input type="checkbox" id="showFaceMesh" />
        <label for="showFaceMesh">Show Face Mesh</label>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showFaceContours" checked />
        <label for="showFaceContours">Show Face Contours</label>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showFaceBox" checked />
        <label for="showFaceBox">Show Face Box</label>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showHandLandmarks" checked />
        <label for="showHandLandmarks">Show Hand Landmarks</label>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showHandBoxes" checked />
        <label for="showHandBoxes">Show Hand Boxes</label>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showPose" />
        <label for="showPose">Show Pose</label>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: rgba(74, 144, 217, 0.3); border-color: #4a90d9"></div>
        <span>Face</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: rgba(255, 138, 0, 0.3); border-color: #ff8a00"></div>
        <span>Left Hand</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: rgba(0, 217, 231, 0.3); border-color: #00d9e7"></div>
        <span>Right Hand</span>
      </div>
    </div>

    <script type="module">
      const videoElement = document.querySelector(".input_video");
      const canvasElement = document.querySelector(".output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const fpsDisplay = document.getElementById("fpsDisplay");
      const trackingStatus = document.getElementById("trackingStatus");

      // Control checkboxes
      const showFaceMesh = document.getElementById("showFaceMesh");
      const showFaceContours = document.getElementById("showFaceContours");
      const showFaceBox = document.getElementById("showFaceBox");
      const showHandLandmarks = document.getElementById("showHandLandmarks");
      const showHandBoxes = document.getElementById("showHandBoxes");
      const showPose = document.getElementById("showPose");

      // Colors
      const FACE_COLOR = "#4a90d9";
      const LEFT_HAND_COLOR = "#ff8a00";
      const RIGHT_HAND_COLOR = "#00d9e7";
      const POSE_COLOR = "#ffffff";

      // FPS calculation
      let lastTime = performance.now();
      let fps = 0;

      function updateFPS() {
        const now = performance.now();
        fps = Math.round(1000 / (now - lastTime));
        lastTime = now;
        fpsDisplay.textContent = `FPS: ${fps}`;
      }

      /**
       * Compute bounding box from landmarks array
       * Returns { x, y, width, height } in pixel coordinates
       */
      function computeBoundingBox(landmarks, canvasWidth, canvasHeight, padding = 0.05) {
        if (!landmarks || landmarks.length === 0) return null;

        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;

        for (const lm of landmarks) {
          minX = Math.min(minX, lm.x);
          minY = Math.min(minY, lm.y);
          maxX = Math.max(maxX, lm.x);
          maxY = Math.max(maxY, lm.y);
        }

        // Add padding
        const width = maxX - minX;
        const height = maxY - minY;
        minX -= width * padding;
        minY -= height * padding;
        maxX += width * padding;
        maxY += height * padding;

        // Convert to pixel coordinates
        return {
          x: minX * canvasWidth,
          y: minY * canvasHeight,
          width: (maxX - minX) * canvasWidth,
          height: (maxY - minY) * canvasHeight,
        };
      }

      /**
       * Draw a bounding box with label
       */
      function drawBoundingBox(ctx, box, color, label) {
        if (!box) return;

        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(box.x, box.y, box.width, box.height);

        // Draw semi-transparent fill
        ctx.fillStyle = color.replace(")", ", 0.1)").replace("rgb", "rgba");
        if (color.startsWith("#")) {
          const r = parseInt(color.slice(1, 3), 16);
          const g = parseInt(color.slice(3, 5), 16);
          const b = parseInt(color.slice(5, 7), 16);
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.1)`;
        }
        ctx.fillRect(box.x, box.y, box.width, box.height);

        // Draw label
        if (label) {
          ctx.font = "bold 14px monospace";
          ctx.fillStyle = color;
          const textWidth = ctx.measureText(label).width;

          // Draw label background
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(box.x, box.y - 20, textWidth + 10, 20);

          // Draw label text
          ctx.fillStyle = color;
          ctx.fillText(label, box.x + 5, box.y - 5);
        }
      }

      /**
       * Draw hand landmarks with connections
       */
      function drawHandLandmarks(ctx, landmarks, color) {
        if (!landmarks) return;

        // Draw connections
        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {
          color: color,
          lineWidth: 2,
        });

        // Draw landmarks
        drawLandmarks(ctx, landmarks, {
          color: color,
          fillColor: color,
          lineWidth: 1,
          radius: 3,
        });
      }

      /**
       * Draw face landmarks with various connection styles
       */
      function drawFaceLandmarks(ctx, landmarks, showMesh, showContours) {
        if (!landmarks) return;

        if (showMesh) {
          // Draw full face mesh tesselation
          drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {
            color: "#C0C0C030",
            lineWidth: 1,
          });
        }

        if (showContours) {
          // Draw face contours (eyes, eyebrows, lips, face oval)
          drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, { color: FACE_COLOR, lineWidth: 1 });
          drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYEBROW, { color: FACE_COLOR, lineWidth: 1 });
          drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, { color: FACE_COLOR, lineWidth: 1 });
          drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYEBROW, { color: FACE_COLOR, lineWidth: 1 });
          drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: FACE_COLOR, lineWidth: 2 });
          drawConnectors(ctx, landmarks, FACEMESH_LIPS, { color: "#E06666", lineWidth: 2 });

          // Draw iris if available (refineFaceLandmarks enables this)
          if (landmarks.length > 468) {
            drawConnectors(ctx, landmarks, FACEMESH_RIGHT_IRIS, { color: "#00FF00", lineWidth: 1 });
            drawConnectors(ctx, landmarks, FACEMESH_LEFT_IRIS, { color: "#00FF00", lineWidth: 1 });
          }
        }
      }

      /**
       * Draw pose landmarks
       */
      function drawPoseLandmarks(ctx, landmarks) {
        if (!landmarks) return;

        drawConnectors(ctx, landmarks, POSE_CONNECTIONS, {
          color: POSE_COLOR,
          lineWidth: 2,
        });
        drawLandmarks(ctx, landmarks, {
          color: POSE_COLOR,
          fillColor: "rgb(0, 217, 231)",
          lineWidth: 1,
          radius: 4,
        });
      }

      /**
       * Main results handler - called when Holistic processing completes
       */
      function onResults(results) {
        updateFPS();

        const canvasWidth = canvasElement.width;
        const canvasHeight = canvasElement.height;

        // Clear canvas and draw video frame
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        canvasCtx.drawImage(results.image, 0, 0, canvasWidth, canvasHeight);

        // Track what's detected
        let faceDetected = false;
        let leftHandDetected = false;
        let rightHandDetected = false;

        // Draw pose if enabled
        if (showPose.checked && results.poseLandmarks) {
          drawPoseLandmarks(canvasCtx, results.poseLandmarks);
        }

        // Process and draw face
        if (results.faceLandmarks) {
          faceDetected = true;

          // Draw face landmarks
          drawFaceLandmarks(canvasCtx, results.faceLandmarks, showFaceMesh.checked, showFaceContours.checked);

          // Draw face bounding box
          if (showFaceBox.checked) {
            const faceBox = computeBoundingBox(results.faceLandmarks, canvasWidth, canvasHeight, 0.1);
            const landmarkCount = results.faceLandmarks.length;
            const label = `Face (${landmarkCount} landmarks)`;
            drawBoundingBox(canvasCtx, faceBox, FACE_COLOR, label);
          }
        }

        // Process and draw left hand
        if (results.leftHandLandmarks) {
          leftHandDetected = true;

          // Draw hand landmarks
          if (showHandLandmarks.checked) {
            drawHandLandmarks(canvasCtx, results.leftHandLandmarks, LEFT_HAND_COLOR);
          }

          // Draw hand bounding box
          if (showHandBoxes.checked) {
            const leftHandBox = computeBoundingBox(results.leftHandLandmarks, canvasWidth, canvasHeight, 0.15);
            drawBoundingBox(canvasCtx, leftHandBox, LEFT_HAND_COLOR, "Left Hand (21 landmarks)");
          }
        }

        // Process and draw right hand
        if (results.rightHandLandmarks) {
          rightHandDetected = true;

          // Draw hand landmarks
          if (showHandLandmarks.checked) {
            drawHandLandmarks(canvasCtx, results.rightHandLandmarks, RIGHT_HAND_COLOR);
          }

          // Draw hand bounding box
          if (showHandBoxes.checked) {
            const rightHandBox = computeBoundingBox(results.rightHandLandmarks, canvasWidth, canvasHeight, 0.15);
            drawBoundingBox(canvasCtx, rightHandBox, RIGHT_HAND_COLOR, "Right Hand (21 landmarks)");
          }
        }

        canvasCtx.restore();

        // Update tracking status display
        trackingStatus.innerHTML = `
          Face: ${faceDetected ? "✓ Tracking" : "-- Not detected"}<br />
          Left Hand: ${leftHandDetected ? "✓ Tracking" : "-- Not detected"}<br />
          Right Hand: ${rightHandDetected ? "✓ Tracking" : "-- Not detected"}
        `;
      }

      // Initialize MediaPipe Holistic
      const holistic = new Holistic({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`,
      });

      // Configure Holistic with recrop technique enabled via refineFaceLandmarks
      // This enables the attention mesh model for better face landmark accuracy
      // The holistic pipeline internally uses the recrop technique:
      // 1. First estimates pose with BlazePose
      // 2. Derives ROIs for hands and face from pose landmarks
      // 3. Uses re-crop models to refine ROIs (spatial transformers)
      // 4. Runs detailed hand/face landmark models on refined crops
      holistic.setOptions({
        modelComplexity: 1, // 0, 1, or 2 - higher = more accurate but slower
        smoothLandmarks: true,
        enableSegmentation: false,
        smoothSegmentation: false,
        refineFaceLandmarks: true, // Enable attention mesh for better eye/lip/iris landmarks
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      holistic.onResults(onResults);

      // Initialize camera
      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await holistic.send({ image: videoElement });
        },
        width: 1280,
        height: 720,
      });

      camera.start();

      // Resize canvas to match video dimensions
      function resizeCanvas() {
        const videoWidth = videoElement.videoWidth || 1280;
        const videoHeight = videoElement.videoHeight || 720;

        canvasElement.width = videoWidth;
        canvasElement.height = videoHeight;
      }

      videoElement.addEventListener("loadedmetadata", resizeCanvas);
      window.addEventListener("resize", resizeCanvas);

      // Initial canvas size
      canvasElement.width = 1280;
      canvasElement.height = 720;
    </script>
  </body>
</html>
