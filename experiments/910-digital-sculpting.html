<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Digital Sculpting - Embodied Experience</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #1e1e1e;
        font-family: "Segoe UI", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
      }

      h1 {
        margin: 10px 0;
        font-size: 1.2rem;
      }

      .description {
        font-size: 0.9rem;
        color: #aaa;
        margin-bottom: 10px;
        text-align: center;
        max-width: 800px;
      }

      .container {
        position: relative;
        width: 1280px;
        height: 720px;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      }

      .input_video {
        display: none;
      }

      .output_canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
      }

      #three-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
        pointer-events: none;
      }

      .fps {
        position: absolute;
        top: 10px;
        right: 10px;
        color: white;
        font-family: monospace;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 10;
        transform: scaleX(-1);
      }

      .tracking-status {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: monospace;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 10;
        transform: scaleX(-1);
        text-align: right;
        line-height: 1.6;
      }

      .sculpt-status {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: white;
        font-family: monospace;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 10;
        transform: scaleX(-1);
      }

      .controls {
        margin-top: 15px;
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
        max-width: 1280px;
      }

      label {
        font-size: 0.9rem;
        cursor: pointer;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 5px;
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 12px;
        border-radius: 6px;
      }

      input[type="checkbox"] {
        cursor: pointer;
      }

      input[type="range"] {
        width: 80px;
      }

      button {
        padding: 8px 16px;
        cursor: pointer;
        border: 1px solid #555;
        background: #333;
        color: white;
        border-radius: 4px;
        font-size: 14px;
        transition: background 0.2s;
      }

      button:hover {
        background: #555;
      }

      .instructions {
        margin-top: 15px;
        font-size: 0.85rem;
        color: #ccc;
        text-align: center;
        max-width: 800px;
        line-height: 1.6;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>
  </head>
  <body>
    <h1>Digital Sculpting - Embodied Experience</h1>
    <p class="description">
      Sculpt a virtual clay head using your hands! Pinch your thumb and index finger together 
      over the clay to sculpt. Move your hand outward to PULL clay, inward to PUSH clay.
    </p>

    <div class="container">
      <video class="input_video"></video>
      <canvas class="output_canvas"></canvas>
      <canvas id="three-canvas"></canvas>
      <div class="fps" id="fpsDisplay">FPS: 0</div>
      <div class="tracking-status" id="trackingStatus">
        Face: --<br />
        Left Hand: --<br />
        Right Hand: --
      </div>
      <div class="sculpt-status" id="sculptStatus">Pinch over clay to sculpt</div>
    </div>

    <div class="controls">
      <div class="control-group">
        <input type="checkbox" id="showFaceContours" checked />
        <label for="showFaceContours">Show Face Contours</label>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showHandLandmarks" checked />
        <label for="showHandLandmarks">Show Hand Landmarks</label>
      </div>
      <div class="control-group">
        <label>Brush Radius:</label>
        <input type="range" id="brushRadius" min="5" max="30" value="15" />
        <span id="brushRadiusValue">15%</span>
      </div>
      <div class="control-group">
        <label>Intensity:</label>
        <input type="range" id="intensity" min="1" max="10" value="5" />
        <span id="intensityValue">5</span>
      </div>
      <button id="resetBtn">Reset Clay</button>
    </div>

    <div class="instructions">
      <strong>How to sculpt:</strong><br />
      1. Position your hand over the clay (your face outline)<br />
      2. Pinch your thumb and index finger together to start sculpting<br />
      3. While pinching, move hand outward (away from camera) to PULL clay or inward to PUSH clay<br />
      4. Release pinch to stop sculpting
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

      const videoElement = document.querySelector(".input_video");
      const canvasElement = document.querySelector(".output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const threeCanvas = document.getElementById("three-canvas");
      const fpsDisplay = document.getElementById("fpsDisplay");
      const trackingStatus = document.getElementById("trackingStatus");
      const sculptStatus = document.getElementById("sculptStatus");

      // Control elements
      const showFaceContours = document.getElementById("showFaceContours");
      const showHandLandmarks = document.getElementById("showHandLandmarks");
      const brushRadiusSlider = document.getElementById("brushRadius");
      const brushRadiusValue = document.getElementById("brushRadiusValue");
      const intensitySlider = document.getElementById("intensity");
      const intensityValue = document.getElementById("intensityValue");
      const resetBtn = document.getElementById("resetBtn");

      // FPS calculation
      let lastTime = performance.now();
      let fps = 0;

      function updateFPS() {
        const now = performance.now();
        fps = Math.round(1000 / (now - lastTime));
        lastTime = now;
        fpsDisplay.textContent = `FPS: ${fps}`;
      }

      // --- THREE.JS SETUP ---
      const scene = new THREE.Scene();

      // Orthographic camera for overlay on video
      const frustumSize = 1;
      let aspect = 1280 / 720;
      const threeCamera = new THREE.OrthographicCamera(
        (frustumSize * aspect) / -2,
        (frustumSize * aspect) / 2,
        frustumSize / 2,
        frustumSize / -2,
        0.01,
        100
      );
      threeCamera.position.set(0, 0, 1);
      threeCamera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true });
      renderer.setSize(1280, 720);

      // Raycaster for projecting hand position onto clay surface
      const raycaster = new THREE.Raycaster();

      // Add lights
      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 2);
      dirLight.position.set(5, 5, 5);
      scene.add(dirLight);

      const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
      backLight.position.set(-5, -5, -5);
      scene.add(backLight);

      // --- CLAY MESH (Sphere representing the head) ---
      const CLAY_SEGMENTS = 64;
      let clayGeometry = new THREE.SphereGeometry(0.15, CLAY_SEGMENTS, CLAY_SEGMENTS);
      const clayMaterial = new THREE.MeshStandardMaterial({
        color: 0xaa8866,
        roughness: 0.6,
        metalness: 0.1,
        flatShading: false,
        transparent: true,
        opacity: 0.85,
      });
      let clayMesh = new THREE.Mesh(clayGeometry, clayMaterial);
      scene.add(clayMesh);
      clayMesh.visible = false;

      // Store the original vertex positions for reset
      let originalPositions = null;

      function resetClay() {
        if (originalPositions && clayMesh.geometry) {
          const positions = clayMesh.geometry.attributes.position;
          for (let i = 0; i < positions.count; i++) {
            positions.setXYZ(
              i,
              originalPositions[i * 3],
              originalPositions[i * 3 + 1],
              originalPositions[i * 3 + 2]
            );
          }
          positions.needsUpdate = true;
          clayMesh.geometry.computeVertexNormals();
        }
      }

      resetBtn.addEventListener("click", resetClay);

      // --- SCULPTING STATE ---
      let sculptingState = {
        isColliding: false,      // Hand is near/touching face
        isPinching: false,       // Thumb and index are close together
        isSculpting: false,      // Actively sculpting (colliding + pinching)
        pinchStartPos: null,     // Position when pinch started
        lastPinchPos: null,      // Last pinch position for direction detection
        activeHand: null,        // 'left' or 'right'
      };

      // Pinch detection threshold (normalized distance)
      const PINCH_THRESHOLD = 0.05;

      // --- COORDINATE CONVERSION ---
      function convertToThreeJS(landmarks) {
        const points = [];
        for (let i = 0; i < landmarks.length; i++) {
          const lm = landmarks[i];
          const x = (lm.x * 2 - 1) * ((frustumSize * aspect) / 2);
          const y = -(lm.y * 2 - 1) * (frustumSize / 2);
          const z = -lm.z * 0.5;
          points.push(new THREE.Vector3(x, y, z));
        }
        return points;
      }

      // Get pinch position (midpoint between thumb tip and index tip)
      function getPinchPosition(handLandmarks) {
        const thumbTip = handLandmarks[4];  // Thumb tip
        const indexTip = handLandmarks[8];  // Index finger tip
        return {
          x: (thumbTip.x + indexTip.x) / 2,
          y: (thumbTip.y + indexTip.y) / 2,
          z: (thumbTip.z + indexTip.z) / 2,
        };
      }

      // Get distance between thumb and index finger
      function getPinchDistance(handLandmarks) {
        const thumbTip = handLandmarks[4];
        const indexTip = handLandmarks[8];
        const dx = thumbTip.x - indexTip.x;
        const dy = thumbTip.y - indexTip.y;
        const dz = thumbTip.z - indexTip.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      }

      // Get face center from landmarks
      function getFaceCenter(faceLandmarks) {
        if (!faceLandmarks || faceLandmarks.length < 468) return null;
        // Use landmark 1 (nose bridge area) as face center reference
        const faceCenter = faceLandmarks[1];
        return { x: faceCenter.x, y: faceCenter.y, z: faceCenter.z };
      }

      // --- SCULPTING LOGIC ---
      function sculpt(point, normal, direction) {
        if (!clayMesh || !clayMesh.visible) return;

        const radius = brushRadiusSlider.value / 100 * 0.3; // Scale to reasonable world units
        const intensity = intensitySlider.value / 10;

        const positions = clayMesh.geometry.attributes.position;
        const count = positions.count;

        // Update bounding box for accurate raycasting on modified geometry
        clayMesh.geometry.computeBoundingBox();

        const vertex = new THREE.Vector3();
        const localPoint = clayMesh.worldToLocal(point.clone()); // Convert hit point to local space
        const localNormal = normal.clone().transformDirection(clayMesh.matrixWorld.clone().invert());

        for (let i = 0; i < count; i++) {
          vertex.fromBufferAttribute(positions, i);

          // Calculate distance in local space
          const dist = vertex.distanceTo(localPoint);

          if (dist < radius) {
            // Smooth Cosine Falloff
            const falloff = 0.5 * (1 + Math.cos((Math.PI * dist) / radius));
            const force = intensity * falloff * 0.02;

            // Apply force along the surface normal
            if (direction > 0) {
              // Pull: add material outward
              vertex.addScaledVector(localNormal, force);
            } else {
              // Push: remove material inward
              vertex.addScaledVector(localNormal, -force);
            }

            positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
          }
        }

        positions.needsUpdate = true;
        clayMesh.geometry.computeVertexNormals();
      }

      // --- DRAWING FUNCTIONS ---
      function drawHandLandmarks(ctx, landmarks, color) {
        if (!landmarks) return;

        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {
          color: color,
          lineWidth: 2,
        });

        drawLandmarks(ctx, landmarks, {
          color: color,
          fillColor: color,
          lineWidth: 1,
          radius: 3,
        });
      }

      function drawFaceLandmarks(ctx, landmarks) {
        if (!landmarks) return;

        drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, { color: "#4a90d9", lineWidth: 1 });
        drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYEBROW, { color: "#4a90d9", lineWidth: 1 });
        drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, { color: "#4a90d9", lineWidth: 1 });
        drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYEBROW, { color: "#4a90d9", lineWidth: 1 });
        drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: "#4a90d9", lineWidth: 2 });
        drawConnectors(ctx, landmarks, FACEMESH_LIPS, { color: "#E06666", lineWidth: 2 });
      }

      // --- MAIN RESULTS HANDLER ---
      function onResults(results) {
        updateFPS();

        const canvasWidth = canvasElement.width;
        const canvasHeight = canvasElement.height;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        canvasCtx.drawImage(results.image, 0, 0, canvasWidth, canvasHeight);

        let faceDetected = false;
        let leftHandDetected = false;
        let rightHandDetected = false;
        let faceCenter = null;

        // Process face
        if (results.faceLandmarks) {
          faceDetected = true;
          faceCenter = getFaceCenter(results.faceLandmarks);

          if (showFaceContours.checked) {
            drawFaceLandmarks(canvasCtx, results.faceLandmarks);
          }

          // Position clay mesh at face location
          if (faceCenter) {
            const facePoints = convertToThreeJS(results.faceLandmarks);
            
            // Calculate face bounding box for clay size
            const bbox = new THREE.Box3().setFromPoints(facePoints);
            const center = new THREE.Vector3();
            bbox.getCenter(center);
            
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const faceSize = Math.max(size.x, size.y) * 0.8;

            clayMesh.position.copy(center);
            clayMesh.scale.setScalar(faceSize / 0.15); // Scale relative to original size

            if (!originalPositions) {
              // Store original positions on first frame
              const positions = clayMesh.geometry.attributes.position;
              originalPositions = new Float32Array(positions.count * 3);
              for (let i = 0; i < positions.count; i++) {
                originalPositions[i * 3] = positions.getX(i);
                originalPositions[i * 3 + 1] = positions.getY(i);
                originalPositions[i * 3 + 2] = positions.getZ(i);
              }
            }

            clayMesh.visible = true;
          }
        } else {
          clayMesh.visible = false;
        }

        // Draw hand landmarks
        if (results.leftHandLandmarks) {
          leftHandDetected = true;

          if (showHandLandmarks.checked) {
            const pinchDist = getPinchDistance(results.leftHandLandmarks);
            const isPinching = pinchDist < PINCH_THRESHOLD;
            const color = isPinching ? "#ff4444" : "#ff8a00";
            drawHandLandmarks(canvasCtx, results.leftHandLandmarks, color);
          }
        }

        if (results.rightHandLandmarks) {
          rightHandDetected = true;

          if (showHandLandmarks.checked) {
            const pinchDist = getPinchDistance(results.rightHandLandmarks);
            const isPinching = pinchDist < PINCH_THRESHOLD;
            const color = isPinching ? "#ff4444" : "#00d9e7";
            drawHandLandmarks(canvasCtx, results.rightHandLandmarks, color);
          }
        }

        // Handle sculpting logic - use raycasting to project hand onto clay
        let handToProcess = null;
        if (results.rightHandLandmarks) {
          handToProcess = results.rightHandLandmarks;
        } else if (results.leftHandLandmarks) {
          handToProcess = results.leftHandLandmarks;
        }

        if (handToProcess && clayMesh.visible) {
          const pinchDist = getPinchDistance(handToProcess);
          const isPinching = pinchDist < PINCH_THRESHOLD;

          if (isPinching) {
            const pinchPos = getPinchPosition(handToProcess);

            // Convert pinch position to normalized device coordinates for raycasting
            const ndcX = pinchPos.x * 2 - 1;
            const ndcY = -(pinchPos.y * 2 - 1);

            // Set up raycaster from camera through pinch position
            raycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), threeCamera);

            // Check for intersection with clay mesh
            const intersects = raycaster.intersectObject(clayMesh);

            if (intersects.length > 0) {
              const hit = intersects[0];
              sculptingState.isColliding = true;

              if (!sculptingState.isPinching) {
                // Just started pinching on the clay
                sculptingState.isPinching = true;
                sculptingState.isSculpting = true;
                sculptingState.pinchStartPos = pinchPos;
                sculptingState.lastPinchPos = pinchPos;
              } else {
                // Continue sculpting - calculate direction based on Z movement
                const zDelta = sculptingState.lastPinchPos.z - pinchPos.z;
                const direction = zDelta > 0 ? 1 : -1; // Positive = pull outward, Negative = push inward

                // Only sculpt if there's significant movement
                if (Math.abs(zDelta) > 0.002) {
                  sculpt(hit.point, hit.face.normal, direction);
                }

                sculptingState.lastPinchPos = pinchPos;
              }
            } else {
              // Ray doesn't hit clay - keep pinching state if already sculpting
              if (sculptingState.isPinching) {
                sculptingState.lastPinchPos = pinchPos;
              }
            }
          } else {
            // Released pinch
            if (sculptingState.isPinching) {
              sculptingState.isPinching = false;
              sculptingState.isSculpting = false;
              sculptingState.isColliding = false;
              sculptingState.pinchStartPos = null;
              sculptingState.lastPinchPos = null;
            }
          }
        } else {
          // No hand detected - reset sculpting state
          sculptingState.isPinching = false;
          sculptingState.isSculpting = false;
          sculptingState.isColliding = false;
          sculptingState.pinchStartPos = null;
          sculptingState.lastPinchPos = null;
        }

        canvasCtx.restore();

        // Render Three.js scene
        renderer.render(scene, threeCamera);

        // Update tracking status
        trackingStatus.innerHTML = `
          Face: ${faceDetected ? "âœ“ Tracking" : "-- Not detected"}<br />
          Left Hand: ${leftHandDetected ? "âœ“ Tracking" : "-- Not detected"}<br />
          Right Hand: ${rightHandDetected ? "âœ“ Tracking" : "-- Not detected"}
        `;

        // Update sculpt status
        if (sculptingState.isSculpting) {
          sculptStatus.textContent = "âœ¨ SCULPTING - Move hand in/out to push/pull clay";
          sculptStatus.style.backgroundColor = "rgba(76, 175, 80, 0.7)";
        } else if (sculptingState.isPinching) {
          sculptStatus.textContent = "ðŸ‘† Pinching - Move over clay to sculpt";
          sculptStatus.style.backgroundColor = "rgba(255, 152, 0, 0.7)";
        } else if (faceDetected && (leftHandDetected || rightHandDetected)) {
          sculptStatus.textContent = "âœ‹ Pinch over clay to sculpt";
          sculptStatus.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        } else if (faceDetected) {
          sculptStatus.textContent = "âœ‹ Show your hand to start";
          sculptStatus.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        } else {
          sculptStatus.textContent = "Looking for face...";
          sculptStatus.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        }
      }

      // --- UI CONTROLS ---
      brushRadiusSlider.addEventListener("input", (e) => {
        brushRadiusValue.textContent = e.target.value + "%";
      });

      intensitySlider.addEventListener("input", (e) => {
        intensityValue.textContent = e.target.value;
      });

      // Initialize MediaPipe Holistic
      const holistic = new Holistic({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`,
      });

      holistic.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        smoothSegmentation: false,
        refineFaceLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      holistic.onResults(onResults);

      // Initialize camera
      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await holistic.send({ image: videoElement });
        },
        width: 1280,
        height: 720,
      });

      camera.start();

      // Resize canvas to match video dimensions
      function resizeCanvas() {
        const videoWidth = videoElement.videoWidth || 1280;
        const videoHeight = videoElement.videoHeight || 720;

        canvasElement.width = videoWidth;
        canvasElement.height = videoHeight;
        renderer.setSize(videoWidth, videoHeight);

        aspect = videoWidth / videoHeight;
        threeCamera.left = (frustumSize * aspect) / -2;
        threeCamera.right = (frustumSize * aspect) / 2;
        threeCamera.top = frustumSize / 2;
        threeCamera.bottom = frustumSize / -2;
        threeCamera.updateProjectionMatrix();
      }

      videoElement.addEventListener("loadedmetadata", resizeCanvas);
      window.addEventListener("resize", resizeCanvas);

      canvasElement.width = 1280;
      canvasElement.height = 720;
    </script>
  </body>
</html>
