<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voxel Sculpting - Hand Tracking</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #1e1e1e;
        font-family: "Segoe UI", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
      }

      h1 {
        margin: 10px 0;
        font-size: 1.2rem;
      }

      .description {
        font-size: 0.9rem;
        color: #aaa;
        margin-bottom: 10px;
        text-align: center;
        max-width: 800px;
      }

      .container {
        position: relative;
        width: 1280px;
        height: 720px;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      }

      .input_video {
        display: none;
      }

      .output_canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
      }

      #three-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
        pointer-events: none;
      }

      .fps {
        position: absolute;
        top: 10px;
        right: 10px;
        color: white;
        font-family: monospace;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 10;
        transform: scaleX(-1);
      }

      .tracking-status {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: monospace;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 10;
        transform: scaleX(-1);
        text-align: right;
        line-height: 1.6;
      }

      .sculpt-status {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: white;
        font-family: monospace;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 10;
        transform: scaleX(-1);
      }

      .controls {
        margin-top: 15px;
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
        max-width: 1280px;
      }

      label {
        font-size: 0.9rem;
        cursor: pointer;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 5px;
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 12px;
        border-radius: 6px;
      }

      input[type="checkbox"] {
        cursor: pointer;
      }

      button {
        padding: 8px 16px;
        cursor: pointer;
        border: 1px solid #555;
        background: #333;
        color: white;
        border-radius: 4px;
        font-size: 14px;
        transition: background 0.2s;
      }

      button:hover {
        background: #555;
      }

      .instructions {
        margin-top: 15px;
        font-size: 0.85rem;
        color: #ccc;
        text-align: center;
        max-width: 800px;
        line-height: 1.6;
      }

      .legend {
        margin-top: 15px;
        display: flex;
        gap: 20px;
        font-size: 0.85rem;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 4px;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>
  </head>
  <body>
    <h1>Voxel Sculpting - Hand Tracking</h1>
    <p class="description">
      Sculpt a voxel structure using your hands! Pinch to select a face, then move your hand to extrude or carve.
    </p>

    <div class="container">
      <video class="input_video"></video>
      <canvas class="output_canvas"></canvas>
      <canvas id="three-canvas"></canvas>
      <div class="fps" id="fpsDisplay">FPS: 0</div>
      <div class="tracking-status" id="trackingStatus">
        Face: --<br />
        Left Hand: --<br />
        Right Hand: --
      </div>
      <div class="sculpt-status" id="sculptStatus">Pinch on a face to select</div>
    </div>

    <div class="controls">
      <div class="control-group">
        <input type="checkbox" id="showHandLandmarks" checked />
        <label for="showHandLandmarks">Show Hand Landmarks</label>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showWireframe" />
        <label for="showWireframe">Show Wireframe</label>
      </div>
      <button id="resetBtn">Reset Voxels</button>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: #ff8a00"></div>
        <span>Left Hand</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #00d9e7"></div>
        <span>Right Hand</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ffff00"></div>
        <span>Selected Face</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ff4444"></div>
        <span>Extruding</span>
      </div>
    </div>

    <div class="instructions">
      <strong>How to sculpt:</strong><br />
      1. Position your hand over a voxel face<br />
      2. Pinch your thumb and index finger together to select the face<br />
      3. While pinching, move hand outward to EXTRUDE (add voxel) or inward to CARVE (remove voxel)<br />
      4. Release pinch to confirm and deselect
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

      const videoElement = document.querySelector(".input_video");
      const canvasElement = document.querySelector(".output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const threeCanvas = document.getElementById("three-canvas");
      const fpsDisplay = document.getElementById("fpsDisplay");
      const trackingStatus = document.getElementById("trackingStatus");
      const sculptStatus = document.getElementById("sculptStatus");

      // Control elements
      const showHandLandmarks = document.getElementById("showHandLandmarks");
      const showWireframe = document.getElementById("showWireframe");
      const resetBtn = document.getElementById("resetBtn");

      // FPS calculation
      let lastTime = performance.now();
      let fps = 0;

      function updateFPS() {
        const now = performance.now();
        fps = Math.round(1000 / (now - lastTime));
        lastTime = now;
        fpsDisplay.textContent = `FPS: ${fps}`;
      }

      // --- THREE.JS SETUP ---
      const scene = new THREE.Scene();

      // Orthographic camera for overlay on video
      const frustumSize = 1;
      let aspect = 1280 / 720;
      const threeCamera = new THREE.OrthographicCamera(
        (frustumSize * aspect) / -2,
        (frustumSize * aspect) / 2,
        frustumSize / 2,
        frustumSize / -2,
        0.01,
        100
      );
      threeCamera.position.set(0, 0, 1);
      threeCamera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true });
      renderer.setSize(1280, 720);

      // Raycaster for face selection
      const raycaster = new THREE.Raycaster();

      // Add lights
      const ambientLight = new THREE.AmbientLight(0x606060, 1.5);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(5, 5, 5);
      scene.add(dirLight);

      const backLight = new THREE.DirectionalLight(0x8888ff, 0.5);
      backLight.position.set(-5, -5, -5);
      scene.add(backLight);

      // --- VOXEL SYSTEM ---
      const GRID_SIZE = 9;
      const VOXEL_SIZE = 0.025; // Size of each voxel in world units
      const HALF_GRID = Math.floor(GRID_SIZE / 2);

      // Voxel grid: true = filled, false = empty
      let voxelGrid = new Map();

      // Group to hold all voxel meshes
      const voxelGroup = new THREE.Group();
      scene.add(voxelGroup);

      // Materials
      const voxelMaterial = new THREE.MeshStandardMaterial({
        color: 0xaa8866,
        roughness: 0.6,
        metalness: 0.1,
        transparent: true,
        opacity: 0.9,
      });

      const selectedMaterial = new THREE.MeshStandardMaterial({
        color: 0xffff00,
        roughness: 0.4,
        metalness: 0.2,
        emissive: 0x444400,
      });

      const extrudingMaterial = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        roughness: 0.4,
        metalness: 0.2,
        emissive: 0x440000,
      });

      const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });

      // Shared geometry for voxels
      const voxelGeometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);
      const wireframeGeometry = new THREE.EdgesGeometry(voxelGeometry);

      // Map to store mesh references
      let voxelMeshes = new Map();

      // Convert grid coordinates to key string
      function gridKey(x, y, z) {
        return `${x},${y},${z}`;
      }

      // Parse key back to coordinates
      function parseKey(key) {
        const [x, y, z] = key.split(",").map(Number);
        return { x, y, z };
      }

      // Convert grid coordinates to world position
      function gridToWorld(x, y, z) {
        return new THREE.Vector3(
          x * VOXEL_SIZE,
          y * VOXEL_SIZE,
          z * VOXEL_SIZE
        );
      }

      // Convert world position to grid coordinates
      function worldToGrid(worldPos) {
        return {
          x: Math.round(worldPos.x / VOXEL_SIZE),
          y: Math.round(worldPos.y / VOXEL_SIZE),
          z: Math.round(worldPos.z / VOXEL_SIZE),
        };
      }

      // Check if voxel exists at grid position
      function hasVoxel(x, y, z) {
        return voxelGrid.has(gridKey(x, y, z));
      }

      // Add voxel at grid position
      function addVoxel(x, y, z) {
        const key = gridKey(x, y, z);
        if (voxelGrid.has(key)) return false;

        voxelGrid.set(key, true);

        // Create mesh
        const mesh = new THREE.Mesh(voxelGeometry, voxelMaterial.clone());
        mesh.position.copy(gridToWorld(x, y, z));
        mesh.userData = { gridX: x, gridY: y, gridZ: z };
        voxelGroup.add(mesh);
        voxelMeshes.set(key, mesh);

        // Add wireframe
        if (showWireframe.checked) {
          const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
          wireframe.position.copy(mesh.position);
          mesh.userData.wireframe = wireframe;
          voxelGroup.add(wireframe);
        }

        return true;
      }

      // Remove voxel at grid position
      function removeVoxel(x, y, z) {
        const key = gridKey(x, y, z);
        if (!voxelGrid.has(key)) return false;

        voxelGrid.delete(key);

        // Remove mesh
        const mesh = voxelMeshes.get(key);
        if (mesh) {
          if (mesh.userData.wireframe) {
            voxelGroup.remove(mesh.userData.wireframe);
          }
          voxelGroup.remove(mesh);
          voxelMeshes.delete(key);
        }

        return true;
      }

      // Initialize with a 9x9x9 cube (actually we start with just the outer shell visible)
      function initializeVoxels() {
        // Clear existing
        voxelGrid.clear();
        voxelMeshes.forEach((mesh) => {
          if (mesh.userData.wireframe) {
            voxelGroup.remove(mesh.userData.wireframe);
          }
          voxelGroup.remove(mesh);
        });
        voxelMeshes.clear();

        // Create a solid 9x9x9 cube
        for (let x = -HALF_GRID; x <= HALF_GRID; x++) {
          for (let y = -HALF_GRID; y <= HALF_GRID; y++) {
            for (let z = -HALF_GRID; z <= HALF_GRID; z++) {
              addVoxel(x, y, z);
            }
          }
        }
      }

      // Get the face normal direction based on which face was hit
      function getFaceDirection(faceIndex) {
        // BoxGeometry face indices: 0-1: +x, 2-3: -x, 4-5: +y, 6-7: -y, 8-9: +z, 10-11: -z
        const faceDirections = [
          { x: 1, y: 0, z: 0 },  // +X
          { x: 1, y: 0, z: 0 },
          { x: -1, y: 0, z: 0 }, // -X
          { x: -1, y: 0, z: 0 },
          { x: 0, y: 1, z: 0 },  // +Y
          { x: 0, y: 1, z: 0 },
          { x: 0, y: -1, z: 0 }, // -Y
          { x: 0, y: -1, z: 0 },
          { x: 0, y: 0, z: 1 },  // +Z
          { x: 0, y: 0, z: 1 },
          { x: 0, y: 0, z: -1 }, // -Z
          { x: 0, y: 0, z: -1 },
        ];
        return faceDirections[faceIndex] || { x: 0, y: 0, z: 1 };
      }

      // Initialize voxels
      initializeVoxels();

      resetBtn.addEventListener("click", initializeVoxels);

      // Toggle wireframe
      showWireframe.addEventListener("change", () => {
        voxelMeshes.forEach((mesh, key) => {
          if (showWireframe.checked) {
            if (!mesh.userData.wireframe) {
              const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
              wireframe.position.copy(mesh.position);
              mesh.userData.wireframe = wireframe;
              voxelGroup.add(wireframe);
            }
          } else {
            if (mesh.userData.wireframe) {
              voxelGroup.remove(mesh.userData.wireframe);
              mesh.userData.wireframe = null;
            }
          }
        });
      });

      // --- SCULPTING STATE ---
      const sculptingState = {
        isSelecting: false,
        selectedVoxel: null,
        selectedFaceDir: null,
        startPinchZ: null,
        lastExtrudeZ: null,
        extrudeThreshold: 0.03, // Z movement threshold to trigger extrude/carve
        highlightedMesh: null,
      };

      // Pinch detection threshold
      const PINCH_THRESHOLD = 0.07;
      const PINCH_RELEASE_THRESHOLD = 0.10;
      let isPinching = false;

      // --- COORDINATE CONVERSION ---
      function convertToThreeJS(landmark) {
        const x = (landmark.x * 2 - 1) * ((frustumSize * aspect) / 2);
        const y = -(landmark.y * 2 - 1) * (frustumSize / 2);
        const z = -landmark.z * 0.5;
        return new THREE.Vector3(x, y, z);
      }

      // Get pinch position (midpoint between thumb tip and index tip)
      function getPinchPosition(handLandmarks) {
        const thumbTip = handLandmarks[4];
        const indexTip = handLandmarks[8];
        return {
          x: (thumbTip.x + indexTip.x) / 2,
          y: (thumbTip.y + indexTip.y) / 2,
          z: (thumbTip.z + indexTip.z) / 2,
        };
      }

      // Get distance between thumb and index finger
      function getPinchDistance(handLandmarks) {
        const thumbTip = handLandmarks[4];
        const indexTip = handLandmarks[8];
        const dx = thumbTip.x - indexTip.x;
        const dy = thumbTip.y - indexTip.y;
        const dz = thumbTip.z - indexTip.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      }

      // --- HEAD ORIENTATION CALCULATION ---
      function calculateHeadOrientation(faceLandmarks) {
        if (!faceLandmarks || faceLandmarks.length < 468) return null;

        const leftEyeOuter = convertToThreeJS(faceLandmarks[33]);
        const rightEyeOuter = convertToThreeJS(faceLandmarks[263]);
        const chin = convertToThreeJS(faceLandmarks[152]);
        const forehead = convertToThreeJS(faceLandmarks[10]);

        const side = new THREE.Vector3().subVectors(leftEyeOuter, rightEyeOuter).normalize();
        const up = new THREE.Vector3().subVectors(forehead, chin).normalize();
        const forward = new THREE.Vector3().crossVectors(side, up).normalize();
        up.crossVectors(forward, side).normalize();

        const rotMatrix = new THREE.Matrix4();
        rotMatrix.makeBasis(side, up, forward);

        return rotMatrix;
      }

      // Get face center from landmarks
      function getFaceCenter(faceLandmarks) {
        if (!faceLandmarks) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        for (const lm of faceLandmarks) {
          sumX += lm.x;
          sumY += lm.y;
          sumZ += lm.z || 0;
        }

        return {
          x: sumX / faceLandmarks.length,
          y: sumY / faceLandmarks.length,
          z: sumZ / faceLandmarks.length,
        };
      }

      // Get face size from landmarks
      function getFaceSize(faceLandmarks) {
        if (!faceLandmarks) return 0;

        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;

        for (const lm of faceLandmarks) {
          minX = Math.min(minX, lm.x);
          maxX = Math.max(maxX, lm.x);
          minY = Math.min(minY, lm.y);
          maxY = Math.max(maxY, lm.y);
        }

        return Math.max(maxX - minX, maxY - minY);
      }

      // --- PROCESS HAND SCULPTING ---
      function processHandSculpting(handLandmarks) {
        if (!handLandmarks) {
          // Reset highlighting when hand not detected
          if (sculptingState.highlightedMesh) {
            sculptingState.highlightedMesh.material = voxelMaterial.clone();
            sculptingState.highlightedMesh = null;
          }
          return { isPinching: false, isSelecting: false };
        }

        const pinchDist = getPinchDistance(handLandmarks);
        const threshold = isPinching ? PINCH_RELEASE_THRESHOLD : PINCH_THRESHOLD;
        const nowPinching = pinchDist < threshold;
        const pinchPos = getPinchPosition(handLandmarks);

        // Convert pinch position to NDC for raycasting
        const ndcX = pinchPos.x * 2 - 1;
        const ndcY = -(pinchPos.y * 2 - 1);

        raycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), threeCamera);
        
        // Get all voxel meshes as array for raycasting
        const meshArray = Array.from(voxelMeshes.values());
        const intersects = raycaster.intersectObjects(meshArray);

        if (!nowPinching) {
          // Not pinching - just highlight hovered face
          if (sculptingState.isSelecting) {
            // Was selecting, now released - confirm the operation
            sculptingState.isSelecting = false;
            sculptingState.selectedVoxel = null;
            sculptingState.selectedFaceDir = null;
            sculptingState.startPinchZ = null;
            sculptingState.lastExtrudeZ = null;
          }

          // Reset previous highlight
          if (sculptingState.highlightedMesh) {
            sculptingState.highlightedMesh.material = voxelMaterial.clone();
            sculptingState.highlightedMesh = null;
          }

          // Highlight hovered voxel
          if (intersects.length > 0) {
            const hit = intersects[0];
            hit.object.material = selectedMaterial.clone();
            sculptingState.highlightedMesh = hit.object;
          }

          isPinching = false;
          return { isPinching: false, isSelecting: false };
        }

        // Pinching
        if (!isPinching && intersects.length > 0) {
          // Just started pinching on a voxel - select it
          const hit = intersects[0];
          const voxelData = hit.object.userData;
          const faceDir = getFaceDirection(hit.faceIndex);

          sculptingState.isSelecting = true;
          sculptingState.selectedVoxel = { x: voxelData.gridX, y: voxelData.gridY, z: voxelData.gridZ };
          sculptingState.selectedFaceDir = faceDir;
          sculptingState.startPinchZ = pinchPos.z;
          sculptingState.lastExtrudeZ = pinchPos.z;
          sculptingState.highlightedMesh = hit.object;

          hit.object.material = extrudingMaterial.clone();

          isPinching = true;
          return { isPinching: true, isSelecting: true, action: "selected" };
        }

        if (sculptingState.isSelecting && sculptingState.selectedVoxel) {
          // Continue selecting - check for extrude/carve based on Z movement
          const zDelta = sculptingState.lastExtrudeZ - pinchPos.z;

          if (Math.abs(zDelta) > sculptingState.extrudeThreshold) {
            const voxel = sculptingState.selectedVoxel;
            const dir = sculptingState.selectedFaceDir;

            if (zDelta > 0) {
              // Moving hand outward (toward camera in raw coords = away in world) - EXTRUDE
              const newX = voxel.x + dir.x;
              const newY = voxel.y + dir.y;
              const newZ = voxel.z + dir.z;

              if (addVoxel(newX, newY, newZ)) {
                // Update selection to the new voxel
                sculptingState.selectedVoxel = { x: newX, y: newY, z: newZ };
                
                // Update highlight
                if (sculptingState.highlightedMesh) {
                  sculptingState.highlightedMesh.material = voxelMaterial.clone();
                }
                const newMesh = voxelMeshes.get(gridKey(newX, newY, newZ));
                if (newMesh) {
                  newMesh.material = extrudingMaterial.clone();
                  sculptingState.highlightedMesh = newMesh;
                }
              }
              sculptingState.lastExtrudeZ = pinchPos.z;
              return { isPinching: true, isSelecting: true, action: "extruded" };
            } else {
              // Moving hand inward - CARVE (remove current voxel)
              // Don't remove if it's the last voxel
              if (voxelGrid.size > 1) {
                // Find the voxel behind in the opposite direction
                const behindX = voxel.x - dir.x;
                const behindY = voxel.y - dir.y;
                const behindZ = voxel.z - dir.z;

                if (removeVoxel(voxel.x, voxel.y, voxel.z)) {
                  // Update selection to the voxel behind (if it exists)
                  if (hasVoxel(behindX, behindY, behindZ)) {
                    sculptingState.selectedVoxel = { x: behindX, y: behindY, z: behindZ };
                    const behindMesh = voxelMeshes.get(gridKey(behindX, behindY, behindZ));
                    if (behindMesh) {
                      behindMesh.material = extrudingMaterial.clone();
                      sculptingState.highlightedMesh = behindMesh;
                    }
                  } else {
                    // No voxel behind, deselect
                    sculptingState.isSelecting = false;
                    sculptingState.selectedVoxel = null;
                    sculptingState.highlightedMesh = null;
                  }
                }
              }
              sculptingState.lastExtrudeZ = pinchPos.z;
              return { isPinching: true, isSelecting: true, action: "carved" };
            }
          }

          return { isPinching: true, isSelecting: true, action: "holding" };
        }

        isPinching = nowPinching;
        return { isPinching: nowPinching, isSelecting: false };
      }

      // --- DRAWING FUNCTIONS ---
      function drawHandLandmarks(ctx, landmarks, color) {
        if (!landmarks) return;

        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {
          color: color,
          lineWidth: 2,
        });

        drawLandmarks(ctx, landmarks, {
          color: color,
          fillColor: color,
          lineWidth: 1,
          radius: 3,
        });
      }

      // --- MAIN RESULTS HANDLER ---
      function onResults(results) {
        updateFPS();

        const canvasWidth = canvasElement.width;
        const canvasHeight = canvasElement.height;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        canvasCtx.drawImage(results.image, 0, 0, canvasWidth, canvasHeight);

        let faceDetected = false;
        let leftHandDetected = false;
        let rightHandDetected = false;

        // Process face - position and orient voxel group
        if (results.faceLandmarks) {
          faceDetected = true;

          const faceCenter = getFaceCenter(results.faceLandmarks);
          const faceSize = getFaceSize(results.faceLandmarks);

          if (faceCenter) {
            const center = convertToThreeJS(faceCenter);
            voxelGroup.position.copy(center);

            // Scale based on face size
            const scale = faceSize * 3.5;
            voxelGroup.scale.setScalar(scale);

            // Apply head orientation
            const rotMatrix = calculateHeadOrientation(results.faceLandmarks);
            if (rotMatrix) {
              voxelGroup.rotation.setFromRotationMatrix(rotMatrix);
            }
          }

          voxelGroup.visible = true;
        } else {
          voxelGroup.visible = false;
        }

        // Process hands
        let sculptResult = { isPinching: false, isSelecting: false };

        // Prefer right hand for sculpting, fall back to left
        if (results.rightHandLandmarks) {
          rightHandDetected = true;

          if (showHandLandmarks.checked) {
            const pinchDist = getPinchDistance(results.rightHandLandmarks);
            const color = pinchDist < PINCH_THRESHOLD ? "#ff4444" : "#00d9e7";
            drawHandLandmarks(canvasCtx, results.rightHandLandmarks, color);
          }

          sculptResult = processHandSculpting(results.rightHandLandmarks);
        } else if (results.leftHandLandmarks) {
          leftHandDetected = true;

          if (showHandLandmarks.checked) {
            const pinchDist = getPinchDistance(results.leftHandLandmarks);
            const color = pinchDist < PINCH_THRESHOLD ? "#ff4444" : "#ff8a00";
            drawHandLandmarks(canvasCtx, results.leftHandLandmarks, color);
          }

          sculptResult = processHandSculpting(results.leftHandLandmarks);
        } else {
          // No hands - reset sculpting state
          if (sculptingState.highlightedMesh) {
            sculptingState.highlightedMesh.material = voxelMaterial.clone();
            sculptingState.highlightedMesh = null;
          }
          sculptingState.isSelecting = false;
          sculptingState.selectedVoxel = null;
          isPinching = false;
        }

        // Also draw the other hand if both are present
        if (results.rightHandLandmarks && results.leftHandLandmarks) {
          leftHandDetected = true;
          if (showHandLandmarks.checked) {
            const pinchDist = getPinchDistance(results.leftHandLandmarks);
            const color = pinchDist < PINCH_THRESHOLD ? "#ff4444" : "#ff8a00";
            drawHandLandmarks(canvasCtx, results.leftHandLandmarks, color);
          }
        }

        canvasCtx.restore();

        // Render Three.js scene
        renderer.render(scene, threeCamera);

        // Update tracking status
        trackingStatus.innerHTML = `
          Face: ${faceDetected ? "âœ“ Tracking" : "-- Not detected"}<br />
          Left Hand: ${leftHandDetected ? "âœ“ Tracking" : "-- Not detected"}<br />
          Right Hand: ${rightHandDetected ? "âœ“ Tracking" : "-- Not detected"}<br />
          Voxels: ${voxelGrid.size}
        `;

        // Update sculpt status
        if (sculptResult.action === "extruded") {
          sculptStatus.textContent = "âž• EXTRUDED!";
          sculptStatus.style.backgroundColor = "rgba(0, 200, 0, 0.7)";
        } else if (sculptResult.action === "carved") {
          sculptStatus.textContent = "âž– CARVED!";
          sculptStatus.style.backgroundColor = "rgba(200, 0, 0, 0.7)";
        } else if (sculptResult.isSelecting) {
          sculptStatus.textContent = "ðŸŽ¯ Face selected - Move hand in/out";
          sculptStatus.style.backgroundColor = "rgba(255, 100, 0, 0.7)";
        } else if (sculptResult.isPinching) {
          sculptStatus.textContent = "ðŸ‘† Pinching - Aim at a face";
          sculptStatus.style.backgroundColor = "rgba(255, 200, 0, 0.7)";
        } else if (sculptingState.highlightedMesh) {
          sculptStatus.textContent = "ðŸ‘† Pinch to select this face";
          sculptStatus.style.backgroundColor = "rgba(100, 100, 255, 0.7)";
        } else if (faceDetected && (leftHandDetected || rightHandDetected)) {
          sculptStatus.textContent = "âœ‹ Hover over voxels to highlight";
          sculptStatus.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        } else if (faceDetected) {
          sculptStatus.textContent = "âœ‹ Show your hand to start";
          sculptStatus.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        } else {
          sculptStatus.textContent = "Looking for face...";
          sculptStatus.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        }
      }

      // Initialize MediaPipe Holistic
      const holistic = new Holistic({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`,
      });

      holistic.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        smoothSegmentation: false,
        refineFaceLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      holistic.onResults(onResults);

      // Initialize camera
      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await holistic.send({ image: videoElement });
        },
        width: 1280,
        height: 720,
      });

      camera.start();

      // Resize canvas to match video dimensions
      function resizeCanvas() {
        const videoWidth = videoElement.videoWidth || 1280;
        const videoHeight = videoElement.videoHeight || 720;

        canvasElement.width = videoWidth;
        canvasElement.height = videoHeight;
        renderer.setSize(videoWidth, videoHeight);

        aspect = videoWidth / videoHeight;
        threeCamera.left = (frustumSize * aspect) / -2;
        threeCamera.right = (frustumSize * aspect) / 2;
        threeCamera.top = frustumSize / 2;
        threeCamera.bottom = frustumSize / -2;
        threeCamera.updateProjectionMatrix();
      }

      videoElement.addEventListener("loadedmetadata", resizeCanvas);
      window.addEventListener("resize", resizeCanvas);

      canvasElement.width = 1280;
      canvasElement.height = 720;
    </script>
  </body>
</html>
